## XOR问题
1. 一组数中，有一个数出现了奇数次其余数都出现了偶数次，求这个数。（要求时间复杂度O(N)，空间复杂度O(1)）
解法：
```
int eor = 0
for (elem in arr):
    eor = eor XOR elem
return eor
eor就是出现了奇数次的数字

原理：因为XOR不考虑顺序，所以假设arr=[1,2,3,1,2,3,1,2,3,1,2]，那么XOR相当于[1,1,1,1,2,2,2,2,3,3,3]而又因为1 XOR 1 XOR 1 XOR 1=0，所有偶数次的XOR最终的结果都是0，偶数次的XOR最终的结果都是他自己，所以最后只剩下0 XOR 3=3.
```

2. 一组数中，两种数都出现了奇数次其余数都出现了偶数次，求这两种数。
解法：
```
int eor = 0
for (elem in arr):
    eor = eor XOR elem

int rightOne = eor & (~eor + 1)
int onlyOne = 0
for (elem in arr){
    if (elem & rightOne != 0){
        onlyOne XOR elem
    }
}
两个数：onlyOne，eor ^ onlyOne

原理：将所有数XOR后的结果就是出现奇数次两数的XOR。然后使用N and (~N + 1)自己与自己取反加一这个技巧取出eor最后一位的1，假设取出最后一位1在第八位，那么意味着出现奇数次两数在第八位不相同（只有这样两者XOR才会在第八位出现1），所以此时数组可以分成两组数，第八位是1的数和第八位是0的数（使用elem and rightOne来挑选，当elem and rightOne不等于0时就说明此elem的数第八位是1），此时再loop一次使用XOR把第八位是1的数过一遍，那么得到的就是第八位是1的且出现了奇数次的数a，然后再用eor XOR a，得到的就是另一个出现了奇数次的数b。
```

## Stack Queue问题
3. 实现一个特殊的Stack，在基本功能的基础上再实现返回Stack中最小元素的功能，要求复杂度O(1)，可以使用现成的Stack结构。
```
解法：除了原本的stack外再另建一个stack叫min，每次往主stack push的时候同时也往min中push一个数，即记录中最小的数（例如往主stack中push了7，但记录中最小的数是3所以仍往min中push一个3），而后调用pop时除了从主stack中pop一个数以外也从min中pop一个数，而min中残留的数就是当前的最小数。

（code见linkedList包下GetMinStack.java）
```

4. 如何用stack去实现queue？如何用queue去实现stack？
```
解法：
用queue实现stack：设置两个queue，一个data一个help，用户push时往data中push，pop时，将data中的数据除了最后push进的数据外其余全pop进help中，剩下最后一个数pop给用户就能模拟出stack的LIFO效果，然后将help和data交换进入下一循环。（举例：push 12345后data中有12345，help为空，假设此时pop，data pop出1234再push进help，help中变为1234，data中剩5，再将data pop给用户相当于FILO。）
用stack实现queue：设置两个stack，一个data一个help，用户push时往data中push后检测help是否为空，若空则将data全部数据pop进help中，pop时，将help pop然后再检测help是否为空若空将data中的数据全部pop进help，最后把pop的值返回给用户达到FIFO效果。

（code见linkedList包下QueueToStack.java和StackToQueue.java）
```

## MergeSort问题
5. 小和问题，求一个数组的小和。（小和即是一组数组中所有数的左边比其小的数加起来的总和，例如[1,3,4,2,5]，1左边比1小的数没有，3左边比3小的数只有1，4左边比1小的数有1和3，2左边比2小的数只有1，5左边比5小的数有1342，所以小和=0+1+1+3+1+1+3+4+2=16）
```
解法：
暴力解法遍历当前数之前的数再比较需要$O(N^2)$。改良解法可以把求“左边比它小的数的总和”变为求“右边比它大的总和”，例如[1,3,4,2,5]，右侧比1大的数有4个，所以记为4个1，右侧比3大的数有两个，记为2个3，右侧比4大的数有1个，记为1个4，右侧比2大的数有1个，记为1个2，右侧比5大的数没有，所以小和=4*1+2*3+1*4+1*2=16.使用MergeSort将数组对半分，左侧记为左右侧记为右，每次merge的时候将左侧数和右侧数对比时如果左数比右数小，就记录一个小和，以此类推最终返回整个数组的小和。

（code见mergeSortQuestions包下SmallSum_MergeSort.java）
```

6. 找出一组数列中所有的逆序对数量。（只要右边比当前数小就可以组成一组逆序对，例如[1,3,4,2,5]，3对应的逆序对有[3,2]）
```
解法：
和第五题相同。
```

## QuickSort问题
7. 荷兰国旗问题：给一个数组和一个目标数，如何让比目标数小的数放最左边，等于目标数的数放中间，比目标数大的数放右边？
```
解法：
首先设置大于区和小于区，小于区从左开始，大于区从最右侧开始，将数组从左到右遍历，分三种情况处理：
1.当前的数小于目标数，就将它和小于区的下一位数做交换（index 0就和自己交换），随后小于区往右移动一位（相当于小于区向右扩充一位），指针右移一位
2.当前数等于目标数，无视直接跳下一位
3.当前的数大于目标数，把当前数和大于区的前一位（大于区左侧一位）做交换，随后大于区左阔一位，但指针原地不变

（此题就是QuickSort逻辑的原型）
```

## Heap问题
已知一个几乎有序的数组，几乎有序指如果把数组排好顺序的话每个元素移动的距离不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。
```
解法：
假设k=6。首先将数组前6个数构建成min-heap，然后将heap的root（heap种最小的数）poll并数组的第0位，接着将数组1-6位在此构建min-heap，把最小的数放入第1位，以此类推，最后当数组只剩下6个数时，把最后的min-heap的最小值弹出依次排好，数组就有序了。

（code见heap包下SortArrayDistanceLessK.java）
```

