1. 一组数中，有一个数出现了奇数次其余数都出现了偶数次，求这个数。（要求时间复杂度O(N)，空间复杂度O(1)）
解法：
```
int eor = 0
for (elem in arr):
    eor = eor XOR elem
return eor
eor就是出现了奇数次的数字

原理：因为XOR不考虑顺序，所以假设arr=[1,2,3,1,2,3,1,2,3,1,2]，那么XOR相当于[1,1,1,1,2,2,2,2,3,3,3]而又因为1 XOR 1 XOR 1 XOR 1=0，所有偶数次的XOR最终的结果都是0，偶数次的XOR最终的结果都是他自己，所以最后只剩下0 XOR 3=3.
```

2. 一组数中，两种数都出现了奇数次其余数都出现了偶数次，求这两种数。
解法：
```
int eor = 0
for (elem in arr):
    eor = eor XOR elem

int rightOne = eor & (~eor + 1)
int onlyOne = 0
for (elem in arr){
    if (elem & rightOne != 0){
        onlyOne XOR elem
    }
}
两个数：onlyOne，eor ^ onlyOne

原理：将所有数XOR后的结果就是出现奇数次两数的XOR。然后使用N and (~N + 1)自己与自己取反加一这个技巧取出eor最后一位的1，假设取出最后一位1在第八位，那么意味着出现奇数次两数在第八位不相同（只有这样两者XOR才会在第八位出现1），所以此时数组可以分成两组数，第八位是1的数和第八位是0的数（使用elem and rightOne来挑选，当elem and rightOne不等于0时就说明此elem的数第八位是1），此时再loop一次使用XOR把第八位是1的数过一遍，那么得到的就是第八位是1的且出现了奇数次的数a，然后再用eor XOR a，得到的就是另一个出现了奇数次的数b。
```

3. 实现一个特殊的Stack，在基本功能的基础上再实现返回Stack中最小元素的功能，要求复杂度O(1)，可以使用现成的Stack结构。
```
解法：除了原本的stack外再另建一个stack叫min，每次往主stack push的时候同时也往min中push一个数，即记录中最小的数（例如往主stack中push了7，但记录中最小的数是3所以仍往min中push一个3），而后调用pop时除了从主stack中pop一个数以外也从min中pop一个数，而min中残留的数就是当前的最小数。

（code见linkedList包下GetMinStack.java）
```

4. 如何用stack去实现queue？如何用queue去实现stack？
```
解法：
用queue实现stack：设置两个queue，一个data一个help，用户push时往data中push，pop时，将data中的数据除了最后push进的数据外其余全pop进help中，剩下最后一个数pop给用户就能模拟出stack的LIFO效果，然后将help和data交换进入下一循环。（举例：push 12345后data中有12345，help为空，假设此时pop，data pop出1234再push进help，help中变为1234，data中剩5，再将data pop给用户相当于FILO。）
用stack实现queue：设置两个stack，一个data一个help，用户push时往data中push后检测help是否为空，若空则将data全部数据pop进help中，pop时，将help pop然后再检测help是否为空若空将data中的数据全部pop进help，最后把pop的值返回给用户达到FIFO效果。

（code见linkedList包下QueueToStack.java和StackToQueue.java）
```
