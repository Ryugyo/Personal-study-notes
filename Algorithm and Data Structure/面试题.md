## XOR问题
1. 一组数中，有一个数出现了奇数次其余数都出现了偶数次，求这个数。（要求时间复杂度O(N)，空间复杂度O(1)）
解法：
```
int eor = 0
for (elem in arr):
    eor = eor XOR elem
return eor
eor就是出现了奇数次的数字

原理：因为XOR不考虑顺序，所以假设arr=[1,2,3,1,2,3,1,2,3,1,2]，那么XOR相当于[1,1,1,1,2,2,2,2,3,3,3]而又因为1 XOR 1 XOR 1 XOR 1=0，所有偶数次的XOR最终的结果都是0，偶数次的XOR最终的结果都是他自己，所以最后只剩下0 XOR 3=3.
```

2. 一组数中，两种数都出现了奇数次其余数都出现了偶数次，求这两种数。
解法：
```
int eor = 0
for (elem in arr):
    eor = eor XOR elem

int rightOne = eor & (~eor + 1)
int onlyOne = 0
for (elem in arr){
    if (elem & rightOne != 0){
        onlyOne XOR elem
    }
}
两个数：onlyOne，eor ^ onlyOne

原理：将所有数XOR后的结果就是出现奇数次两数的XOR。然后使用N and (~N + 1)自己与自己取反加一这个技巧取出eor最后一位的1，假设取出最后一位1在第八位，那么意味着出现奇数次两数在第八位不相同（只有这样两者XOR才会在第八位出现1），所以此时数组可以分成两组数，第八位是1的数和第八位是0的数（使用elem and rightOne来挑选，当elem and rightOne不等于0时就说明此elem的数第八位是1），此时再loop一次使用XOR把第八位是1的数过一遍，那么得到的就是第八位是1的且出现了奇数次的数a，然后再用eor XOR a，得到的就是另一个出现了奇数次的数b。
```

## Stack Queue问题
3. 实现一个特殊的Stack，在基本功能的基础上再实现返回Stack中最小元素的功能，要求复杂度O(1)，可以使用现成的Stack结构。
```
解法：除了原本的stack外再另建一个stack叫min，每次往主stack push的时候同时也往min中push一个数，即记录中最小的数（例如往主stack中push了7，但记录中最小的数是3所以仍往min中push一个3），而后调用pop时除了从主stack中pop一个数以外也从min中pop一个数，而min中残留的数就是当前的最小数。

（code见linkedList包下GetMinStack.java）
```

4. 如何用stack去实现queue？如何用queue去实现stack？
```
解法：
用queue实现stack：设置两个queue，一个data一个help，用户push时往data中push，pop时，将data中的数据除了最后push进的数据外其余全pop进help中，剩下最后一个数pop给用户就能模拟出stack的LIFO效果，然后将help和data交换进入下一循环。（举例：push 12345后data中有12345，help为空，假设此时pop，data pop出1234再push进help，help中变为1234，data中剩5，再将data pop给用户相当于FILO。）
用stack实现queue：设置两个stack，一个data一个help，用户push时往data中push后检测help是否为空，若空则将data全部数据pop进help中，pop时，将help pop然后再检测help是否为空若空将data中的数据全部pop进help，最后把pop的值返回给用户达到FIFO效果。

（code见linkedList包下QueueToStack.java和StackToQueue.java）
```

## MergeSort问题
5. 小和问题，求一个数组的小和。（小和即是一组数组中所有数的左边比其小的数加起来的总和，例如[1,3,4,2,5]，1左边比1小的数没有，3左边比3小的数只有1，4左边比1小的数有1和3，2左边比2小的数只有1，5左边比5小的数有1342，所以小和=0+1+1+3+1+1+3+4+2=16）
```
解法：
暴力解法遍历当前数之前的数再比较需要$O(N^2)$。改良解法可以把求“左边比它小的数的总和”变为求“右边比它大的总和”，例如[1,3,4,2,5]，右侧比1大的数有4个，所以记为4个1，右侧比3大的数有两个，记为2个3，右侧比4大的数有1个，记为1个4，右侧比2大的数有1个，记为1个2，右侧比5大的数没有，所以小和=4*1+2*3+1*4+1*2=16.使用MergeSort将数组对半分，左侧记为左右侧记为右，每次merge的时候将左侧数和右侧数对比时如果左数比右数小，就记录一个小和，以此类推最终返回整个数组的小和。

（code见mergeSortQuestions包下SmallSum_MergeSort.java）
```

6. 找出一组数列中所有的逆序对数量。（只要右边比当前数小就可以组成一组逆序对，例如[1,3,4,2,5]，3对应的逆序对有[3,2]）
```
解法：
和第五题相同。
```

## QuickSort问题
7. 荷兰国旗问题：给一个数组和一个目标数，如何让比目标数小的数放最左边，等于目标数的数放中间，比目标数大的数放右边？
```
解法：
首先设置大于区和小于区，小于区从左开始，大于区从最右侧开始，将数组从左到右遍历，分三种情况处理：
1.当前的数小于目标数，就将它和小于区的下一位数做交换（index 0就和自己交换），随后小于区往右移动一位（相当于小于区向右扩充一位），指针右移一位
2.当前数等于目标数，无视直接跳下一位
3.当前的数大于目标数，把当前数和大于区的前一位（大于区左侧一位）做交换，随后大于区左阔一位，但指针原地不变

（此题就是QuickSort逻辑的原型）
```

## Heap问题
8. 已知一个几乎有序的数组，几乎有序指如果把数组排好顺序的话每个元素移动的距离不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。
```
解法：
假设k=6。首先将数组前6个数构建成min-heap，然后将heap的root（heap种最小的数）poll并数组的第0位，接着将数组1-6位在此构建min-heap，把最小的数放入第1位，以此类推，最后当数组只剩下6个数时，把最后的min-heap的最小值弹出依次排好，数组就有序了。

（code见heap包下SortArrayDistanceLessK.java）
```

## LinkedList问题
9. 如何用时间复杂度O(N)空间复杂度O(1)的算法判断一个单链表是否为回文？
```
解法：
设置快慢指针，快指针走向末尾满指针走向中央，然后将中央右边的单链表翻转，再和头部两两对比，如果都对应就是回文，有一个node不同就false。
（code见linkedList包PalindromeList.java）
```

10. 将一个单链表排序成左边小中间相等右边大的形式。
```
解法：
笔试时直接将数值提取出来然后quicksort，面试时如果要求额外复杂度O(1)，就设置6个变量：小头，小尾，中头，中尾，大头，大尾。接着挑list开头作为target，然后遍历list，分三种情况：
1. node小于target：如果小头小尾都为null那么将此两者指向node，如果小头小尾不为null，那么将小尾的next指向node，并将node作为新小尾。
2. node大于target：如果大头大尾都为null那么将此两者指向node，如果大头大尾不为null，那么将大尾的next指向node，并将node作为新大尾。
3. node等于target：如果中头中尾都为null那么将此两者指向node，如果中头中尾不为null，那么将中尾的next指向node，并将node作为新中尾。
最后，将小尾链接中头，中尾链接大头即可（要小心，有可能没有小于等于或大于target的node，所以要写null case）。
```

11. 给定两个可能有环也可能无环的单链表，head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交，返回null。要求时间O(N)和空间O(1)。
```
解法：
首先判断有没有环。构建一个hashset，每遍历一个node如果set里没有就将node放入hashset，直到遇到环（也就是查询hashset发现node已经存在）此时返回入环的第一个node。
拓展：不用外部结构判断单链表是否有环。准备快慢指针，快每次走两步，慢每次走一步，如果单链表有环，那么快慢指针一定在某个节点相遇，相遇后，快指针回到开头，慢指针呆在原地，然后快慢指针再次以每步一步的速度前进，当他们再相遇的第一个点就是入环的node。

如果无环，先找两个链表的end node，如果两个单链表相交，那么两个链表最后的end node内存地址一定是相同的。如果不同就直接return false因为不相交，如果相同，此时假如链表1的长度是100，链表2的长度是80，那么链表1先走20步，接着链表2也开始走，那么他和链表1相遇的第一个node一定是第一个相交的node。

如果有环，分三种情况：
1. 两个单链表各自有环，不相交独立
2. 两个单链表相交在某个node，公用一个环
3. 两个单链表在环上相交
如果两个单链表上的环node相等，说明如果相交也在环上相交，那么用无环求相交节点同样的方式求交点，区别就在于每个链表的终点是他们各自的loop节点而不是null，在循环时如果两个链表没有相遇，就是情况1，如果相遇，就是情况2。如果两个链表的环node不相同（说明两个链表若相交只会在环上），那么如果循环链表1肯定会在某一点碰见链表2的环node，如果碰见就返回相交node。
（code见linkedList包下IntersectLinkedList.java）
```

## BinaryTree问题
12. 找出一个树最多一层有多少node。
```
解法：
使用hashmap记录所有node的所在层数，再记录：当前层，当前层node数，最大node数，每次遍历，对比当前层和node所在层数，若相等，当前层node数+1，若不等，说明queue已经开始遍历下一层node，统计当前层node数和已知最大node数对比、替换，当前层+1；一直重复循环直到queue空，此时max就是最大层数拥有的node数量。
（code见binaryTree包下FIndMaxWidth.java）
```

13. BinaryTree的递归套路
```
对于“判断是否为xxxx”的DP问题，首先取得：什么情况下才会满足条件，然后根据条件写递归。例子：
1. 什么条件才叫搜索二叉树？
条件：左边是搜索，右边是搜索，左max<root，右min>root
2. 需求什么信息？
信息：左max，右min，左右是否为bst
3. 根据构建返回类型
boolean isBST；int min；int max
4. 写递归
写basecase，如果为null返回什么
递归左树和右树，分别返回一个自建返回类型值
代入条件，初始isBST=true设置条件改为false
总和当前node的isBST，min，max，返回新的类型值

（code见binaryTree包下IsBalancedTree.java和IsBinarySearchTree.java）
```

14. 给定两个binaryTree节点node1和node2，找他们最低公共祖先节点（两个点往上最早汇聚的点就叫最低公共祖先节点）。
```
解法：
先用hashmap把head遍历到末尾的所有node和它的father储存起来。再建立一个hashset，根据hashmap内的父类信息储存node1一直到root的所有node，接着遍历node2，如果node2再往上的遍历过程中和hashset内的某个node相等了，那么这个node就是node1和node2的最低公共祖先节点。

（code见binaryTree包下LowestCommonAncestor.java）
```

15. 在二叉树中找一个节点的后继节点。
后继节点：中序遍历中一个节点的下一个节点