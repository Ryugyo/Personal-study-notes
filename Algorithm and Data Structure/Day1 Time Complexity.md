# Time Complexity
算法的time complexity就是在常数操作数量级的表达式中只取最高阶项，而且忽略掉最高阶项的系数和剩下的东西。

For example：
$aN^2 + bn + 1$
只取$N^2$这个最高项，所以复杂度是O($N^2$).

## Big O
- 估计得是一个算法的complexity上限，瓶颈（最差情况下）。
- 评价一个算法流程的好坏，O越小表明算法越好，但如果都是同样的指标比如都是O(N)，那么就要比较常数项（用实际代码跑的方式去区分）。

## 额外空间复杂度
实现算法的流程需要开辟一些空间来支持算法，除去输入参数的空间和输出结果的空间，剩下申请的和功能无关的空间就是额外空间复杂度。如果流程只需要开辟几个变量，那么额外空间复杂度就是O(1)；如果需要开辟新的数组才能完成操作，那么就是O(N)。

## 最优解
一般情况下认为一个问题的算法流程在时间复杂度上尽可能低，先满足时间复杂度，再是用最少的空间的算法流程就称为最优解。

## 常见复杂度
排名从好到差：
$O(1), O(logN), O(N), O(N logN), O(N^2),... , O(N!)$

## 对数器
用来验证算法究竟有没有问题，操作步骤如下：
1. 假设希望测试的算法是A，再设想个暴力解法的算法B（例如暴力递归）
2. 生成很多Random input（例如50万组input）
3. 将input放入A和B一起验证，如果发现A和B答案不同，那么再debug
***

## O($N^2$)的Sort Algorithms
- BubbleSort：两两对比，若后小于前则交换。
- SelectionSort：走N轮，每轮选出最小的数放在最前面。
- InsertionSort：从index 1开始将每个数和它之前所有的数做对比，若小于前数则交换，一路比较至前面没有数或前一个数比它小为止。

## 异或运算（exclusive or）
例如a=10110, b=00111，a XOR b=10001
性质：0 XOR N=N; N XOR N=0; 满足交换律和结合律

应用-快速swap方法：
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j];
arr[i] = arr[i] ^ arr[j];

原理：
第一行后：a=a XOR b; b=b
第二行后：a=a XOR b; b=b XOR (a XOR b) = a
第三行后：a=(a XOR b) XOR a = b; b=a

缺陷：如果i位置和j位置指向的是相同内存，执行这三行后就会把两个位置的值都抹成0了（比如array中同一个位置，swap arr[0]和arr[0]相当于自己XOR自己=0）。所以上述swap方法不推荐经常使用。

## 二分法（dichotomy）
1. 找一个有序数组中某个数是否存在
2. 在一个有序数组中找>=某个数最左侧的位置
3. 在一个有序数组中找>=某个数最右侧的位置
4. 局部最小值问题

如果使用遍历法复杂度是O(N)太复杂，因为数组已经是有序了所以可以将数组中间记为mid然后看左边或右边，这样复杂度就优化为了O(logN)。
**（代码见dichotomy package）**
