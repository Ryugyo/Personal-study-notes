## Disjoint Set
并查集：有若干的样本abcd类型都是v，在并查集中一开始认为每个样本都在独立的集合里，用户可以在任何时候调用两个方法：
boolean isSameSet(x,y)查询样本x和y是否在一个集合
void union(x,y)把x和y各自所在的集合合并成一个

每一个元素都自带一个指针，首先都指向自己，合并时指针指向另一个合并的元素和其之下所有的元素（集合）。如何检查两个元素是否在一个集合？顺着元素x的指针指向最高层（代表），顺着元素y的指针指向代表，如果两个代表相同，则在同一个集合内。
如何合并？找到元素x和y的代表点，小集合（集合内元素少）的代表指针挂在大集合的代表下，就完成合并。
（code见disjointSet底下DisjointSet.java）

## BackTracking
暴力递归：把问题转化为规模更小的同类问题，有明确的不需要进行递归的base case，有当得到了子问题的结果之后的决策，不记录每一个子问题的解。

汉诺塔问题（Tower of Hanoi）：假设有三个杆，左杆上有n个盘子，要求：把所有盘子移动到最右杆，但过程中大盘子不能在小盘子之上。
最优步骤：先把1-（n-1）的圆盘移动到最中央的杆，再把n移动到最右，最后把1-（n-1）的圆盘从中间移动到右边。
优化解法：抛弃左中右，把当前的杆一律看作from，要去的杆看作to，过渡的杆看作other，只需要三个参数便可。
Hanoi问题步数：$2^N-1$
（code见backTracking包下HanoiTower.java）
